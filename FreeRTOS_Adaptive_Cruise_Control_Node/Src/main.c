/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 **/

/* -------------------------------Includes -----------------------------------*/
/* General Includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "../Inc/Drivers/LIB/BIT_MATH.h"
#include "../Inc/Drivers/LIB/STD_TYPES.h"
/* USER CODE END Includes */

/* FreeRTOS includes ---------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "timers.h"
/* USER CODE END Includes */

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "../Inc/Drivers/Inc/RCC_interface.h"
#include "../Inc/Drivers/Inc/USART_interface.h"
#include "../Inc/Drivers/Inc/GPIO_interface.h"
#include "../Inc/Drivers/Inc/TIM_interface.h"
/* USER CODE END Includes */
/* ---------------------------------------------------------------------------*/


/* ------------------------Private typedef -----------------------------------*/
/* USER CODE BEGIN PTD */
typedef struct
{
	u8 		Object_Distances[2] ;
	u8 		Pointer	;
	f32 	Object_Speed ;
	u64 	Object_Timer ;

}OBJECT_STRUCT;
/* USER CODE END PTD */
/* ---------------------------------------------------------------------------*/


/* ------------------------Private define ------------------------------------*/
/* USER CODE BEGIN PD */
#define  	_10S_					pdMS_TO_TICKS(10000)
#define  	_1S_					pdMS_TO_TICKS(1000)
#define		_THE_STOP_CHAR_			'#'
#define 	_FRAME_SIZE_			4		// in (Char)
// Bump Definitions
#define 	_BUMP_DEFAULT_DIST_ 	100  	// in (m)
#define 	_BUMP_CROSS_SPEED_ 		5		// in (Km/H)
// the size of the Queue.
#define 	QueueSize				sizeof(OBJECT_STRUCT)
/* USER CODE END PD */
/* ---------------------------------------------------------------------------*/


/* -------------------------Private macro ------------------------------------*/
/* USER CODE BEGIN PM */
/* A Macro to convert the Ticks number into MS */
#define pdTICKS_TO_MS( xTicks )    (((u64)( xTicks ) * 1000u )/configTICK_RATE_HZ )
/* USER CODE END PM */
/* ---------------------------------------------------------------------------*/


/* -----------------------Private variables ----------------------------------*/
/* USER CODE BEGIN PV */
// UART_Handler :
USART_HANDLE UART_2 =
{
	.USART_x 		= 			USART2_R
};

// Private UART Configuration structs :
MUSART_Frame_Config         Serial_Frame        =
{
	.M_VALUE        =           _8_Bit              ,
	.parity_op      =           Parity_Disable       ,
	.Stop_Bit_NUM   =           _1_0_Bit
};
MUSART_Receiving_Config     Serial_Receiving    =
{
	.OneBit_Sampling_method =     	One_Sample  ,
	.Oversampling_type      =       Sampling_By_8
};

// Timer handler :
TIM_HANDLER Uart_timer =
{
    .TIMx 			= 			TIM1_R,
	.Count_M 		= 			Count_UP,
	.preload_State 	= 			ARR_Buffered,
	.Peri_Clock 	= 			Internal_clk
};

// GPIO Definitions :
PIN_st	Uart2_Tx =
{
    .PIN_MOD 		= 			AF,
    .PIN_OT 		= 			PP,
    .PIN_SPD 		= 			MS,
    .PIN_PUPD 		= 			PD

};

PIN_st	Uart2_Rx =
{
    .PIN_MOD 		= 			AF,
    .PIN_OT 		= 			PP,
    .PIN_SPD 		= 			MS,
    .PIN_PUPD 		= 			PD

};

// Global Variable that stores the car's Speed.
f32 * Car_Speed	;
f32 Car_Limit = 100 ;

/* USER CODE END PV */
/* ---------------------------------------------------------------------------*/


/* ------------------Private function prototypes -----------------------------*/
void vReceiveFromUartTask(void * pvParameters);
void vFilterTask(void* pvParameters);
void vTransmitToUartTask(void * pvParameters);
void vCalcObjectSpeedTask(void * pvParameters);
void vCalcCarNewSpeedTask(void * pvParameters);
void vBumpHandlingTask(void * pvParameters);

/* USER CODE BEGIN PFP */
void add_callbackRX(USART_HANDLE *USARTx);
void vDumpTimerCallBack(TimerHandle_t Bump_Dist_Timer);
/* USER CODE END PFP */
/* ---------------------------------------------------------------------------*/


/* -----------------------Private user code ----------------------------------*/
/* USER CODE BEGIN 0 */
SemaphoreHandle_t 	Receive_Mutex	;
QueueHandle_t 		Uart_Message_Queue 			= NULL ; // Receive Task queue
QueueHandle_t		qCalcObjectSpeedTask_Queue 	= NULL ; // Calculate Object Speed queue queue
QueueHandle_t		Object_Queue 				= NULL ; // Objects' Queue
QueueHandle_t		SpeedLimit_Queue 			= NULL ; // Speed Limit Queues
QueueHandle_t		Uart_Transmit_Queue 		= NULL ; // Transmit Task Queue

// Car new speed Queue set.
QueueSetHandle_t	CarNewSpeed_QueueSet		= NULL ;

TimerHandle_t		Bump_Dist_Timer		= NULL ; // the timer for Calculate the distance between the car and the bump

TaskHandle_t 		tReceiveFromUartTask ;
TaskHandle_t		tFilterTask			 ;
TaskHandle_t		tCalcObjectSpeedTask ;
TaskHandle_t		tCalcCarNewSpeedTask ;
TaskHandle_t		tBumpHandlingTask 	 ;
TaskHandle_t		tTransmitToUartTask  ;
/* USER CODE END 0 */
/* ---------------------------------------------------------------------------*/


int main(void)
{
	// Peripheral Initialization :
		/* RCC Definition */
	MRCC_voidSystemClkInit();
	MRCC_voidPeripheralEnable(AHB1 , GPIOAEN);
	MRCC_voidPeripheralEnable(APB1 , USART2EN);
	MRCC_voidPeripheralEnable(APB2 , TIM1EN);

		/* TIMER Definitions */
	MCAL_TIM_General_Config(&Uart_timer);
	MCAL_TIM_Prescaler(&Uart_timer, 16000);
	MCAL_TIM_Reload_Value(&Uart_timer, _AUTO_RELOAD_MAX_);

		/* UART Definitions */
	MCAL_UART_Init_(&UART_2, &Serial_Frame, &Serial_Receiving, 112500, &Uart_timer);
	MCAL_UART_Enable(&UART_2);

		/* GPIO Definitions */
	GPIO_voidSetPinDirection(GPIO_PORTA, PIN2, &Uart2_Tx); // Uart2-TX.
	GPIO_voidSetPinDirection(GPIO_PORTA, PIN3, &Uart2_Rx); // Uart2-RX.
	GPIO_voidSetAlternativeFunction(GPIO_PORTA , PIN2 , GPIO_AF_7);
	GPIO_voidSetAlternativeFunction(GPIO_PORTA , PIN3 , GPIO_AF_7);

	// FreeRTOS inititalization :
	Receive_Mutex 		= xSemaphoreCreateMutex();

	Uart_Message_Queue 			= xQueueCreate(3,sizeof(u8)	); // Receive Task queue
	qCalcObjectSpeedTask_Queue 	= xQueueCreate(2,sizeof(u8)	); // Calculate Object Speed queue
	Object_Queue 				= xQueueCreate(1,sizeof(f32)); // object Queues
	SpeedLimit_Queue 			= xQueueCreate(1,sizeof(f32)); // Speed Limit Queues
	Uart_Transmit_Queue 		= xQueueCreate(1,sizeof(f32)); // Transmit Task Queue

	CarNewSpeed_QueueSet		= xQueueCreateSet(2*(sizeof(f32))); // the queue that receive any change in the speed.

	// Adding Element to the QueueSet.
	xQueueAddToSet(Object_Queue, CarNewSpeed_QueueSet);
	xQueueAddToSet(SpeedLimit_Queue, CarNewSpeed_QueueSet);

	// FreeRTOS Tasks Declerations :
	xTaskCreate( tReceiveFromUartTask , "tReceiveFromUartTask"  	, 100 , NULL , 10U 	, vReceiveFromUartTask ); // the Task that Receive the data from the UART
	xTaskCreate( tTransmitToUartTask  , "tTransmitToUartTask"  		, 100 , NULL , 9U 	, vTransmitToUartTask ); // the Task that transmit the data to the UART
	xTaskCreate( tFilterTask		  , "tFilterTask"  				, 100 , NULL , 8U 	, vFilterTask 			); // the Task that Receive the data from the UART
	xTaskCreate( tBumpHandlingTask 	  , "tBumpHandlingTask"  		, 100 , NULL , 7U 	, vBumpHandlingTask    ); // the task that handle the bump, this task should take high periority.
	xTaskCreate( tCalcCarNewSpeedTask , "tCalcCarNewSpeedTask"  	, 100 , NULL , 4U 	, vCalcCarNewSpeedTask ); // the Task that Detect the Car new Speed
	xTaskCreate( tCalcObjectSpeedTask , "tCalcObjectSpeedTask"  	, 100 , NULL , 3U 	, vCalcObjectSpeedTask ); // the Task that Detect the Object Speed

	// start the RTOS scheduler :
	vTaskStartScheduler();
}

/*---------------------------------------------------------------------------------------------------------------------*/
/* Special Functions Implementation : ---------------------------------------------------------------------------------*/
// the Uart Receive_interrupt mode callback function.
void add_callbackRX(USART_HANDLE *USARTx)
{
	// start from the Highest priority task or not.
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	// Take the Mutex to Start the task.
	xSemaphoreTake( Receive_Mutex , portMAX_DELAY );

	if(USARTx ->RX_Buffer_Ptr[USARTx -> RX_Process_Count]  == USARTx ->RX_Buffer_lastEL)
	{
		// Give the Semaphore.
		xSemaphoreGiveFromISR( Receive_Mutex , &xHigherPriorityTaskWoken );
	}

	//Return to the RTOS.
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
// the Bump Timer Handling function.
void vDumpTimerCallBack(TimerHandle_t Bump_Dist_Timer)
{
	// Resume the BumpHandling task each (1-S).
	vTaskResume(tBumpHandlingTask);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*---------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------*/
/* Tasks Implementation : ---------------------------------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the Task that Receive From Uart : task 1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vReceiveFromUartTask(void * pvParameters)
{
	u8 		*Received_Data_Pointer 	= 0;
	u8		error_counter 			= 0;
	u32		local_waitTime			= pdMS_TO_TICKS(0);
	u8		_BUFFER_SIZE_ 			= 10;

	MCAL_UART_INTT_CALLBACK(&UART_2, RXNE_INT, add_callbackRX);

	while(1)
		{
			// 1- Take the Mutex to Start the task.
			xSemaphoreTake( Receive_Mutex , portMAX_DELAY );

			// 2- Put the Received message into a Filter Queue.
			if( sizeof(Received_Data_Pointer) == _FRAME_SIZE_ )
			{
				xQueueSend( Uart_Message_Queue , Received_Data_Pointer , local_waitTime );
				error_counter =0;
			}
			else
			{
				error_counter++;
			}

			// 3- Restart the receive function.
			MCAL_UART_Receive_INT( &UART_2 , Received_Data_Pointer, _BUFFER_SIZE_ , _THE_STOP_CHAR_ );

			// 5- Give the Semaphore to stop the task.
			xSemaphoreGive( Receive_Mutex );

//			// 4- Small delay for stability.
//			vTaskDelay(10);
		};
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the Task that filter the Received data and send it to its next task : task 2
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vFilterTask(void* pvParameters)
{
	u8 	local_message_counter 	;
	u8 	*General_Array		= 0	;
	u8 	Distance_Var		= 0 ;
	u8  Frame_Size			= 0 ;
	while(1)
	{
		xQueueReceive( Uart_Message_Queue , General_Array , 0 );
		local_message_counter = 0 ;
		Frame_Size = sizeof(*General_Array);
		while( local_message_counter < Frame_Size)
		{
			if ( General_Array[local_message_counter] == 'D')
			{
				Distance_Var = General_Array[ local_message_counter + 1];
				xQueueSend( qCalcObjectSpeedTask_Queue , &Distance_Var, 0 );

				local_message_counter += 2;
			}
			else if (General_Array[local_message_counter] == 'S')
			{
				if(General_Array[local_message_counter + 1]== 's') // received a speed limit signal from the [Master Node] as a Sign.
                {
					Car_Limit = General_Array[local_message_counter + 2];
					local_message_counter += 3;
				}
				else if(General_Array[local_message_counter + 1]== 'b') // received a bump signal from the [Master Node] as a Sign.
				{
					// resume the Bump task.
					vTaskResume(tBumpHandlingTask);
					local_message_counter += 2	;
				}
			}
			else if (General_Array[local_message_counter] == 'B') // received a bump signal from the [interface Node].
			{
				// resume the Bump task.
				vTaskResume(tBumpHandlingTask);
				local_message_counter++	;
			}
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the Task that Calculate the Speed of the Object : task 3
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vCalcObjectSpeedTask(void * pvParameters)
{
	// received data buffer.
	u8 dataBuffer;
	// Objects' Struct :
	OBJECT_STRUCT	Object_Struct = {0} ;
	while(1)
	{
		// receive all date.
		xQueueReceive(qCalcObjectSpeedTask_Queue, &dataBuffer, portMAX_DELAY); // the enable Signal.

		// 1- store the first distance.
		Object_Struct.Object_Distances[Object_Struct.Pointer] = dataBuffer; // the number is a 'Char'.

		if (Object_Struct.Pointer == 0) {

			// 1- start the timer.
			Object_Struct.Object_Timer = pdTICKS_TO_MS(xTaskGetTickCount());

			// 2- make the pointer to the second distance.
			Object_Struct.Pointer++ ;

			// 3 clear the second distance.
			Object_Struct.Object_Distances[1] = 0;
		}
		else {
			// 1- get the time, then stop the timer.
			if (Object_Struct.Object_Timer > pdTICKS_TO_MS(xTaskGetTickCount()) )
			{
			// we get the time in seconds here.
			Object_Struct.Object_Timer = (pdTICKS_TO_MS( (xTaskGetTickCount()+portMAX_DELAY) )-(Object_Struct.Object_Timer))/(1000);
			}
			else
			{
				Object_Struct.Object_Timer = (pdTICKS_TO_MS(xTaskGetTickCount())-(Object_Struct.Object_Timer))/(1000);
			}

			// 2- calculate the speed :
			Object_Struct.Object_Speed = (((Object_Struct.Object_Distances[1]-Object_Struct.Object_Distances[0])/(Object_Struct.Object_Timer)) + (*Car_Speed));

			// 3- Send the Speed of the Object to the next task :
			xQueueSend(Object_Queue , &Object_Struct.Object_Speed ,0);

			// 4- return the pointer to 1 again.
			Object_Struct.Pointer = 0 ;
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the Task that Detect the Car new Speed : task 4 , it should take the highest periority amoung the action tasks.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vCalcCarNewSpeedTask(void * pvParameters)
{
	QueueHandle_t 	DataSource_Queue	= NULL ;
	f32 *ReceivedSpeed = 0;
	*Car_Speed = 0;
	while(1)
	{
		// Receive the Data from the set.
		DataSource_Queue = xQueueSelectFromSet(CarNewSpeed_QueueSet, portMAX_DELAY);
		xQueueReceive(DataSource_Queue , ReceivedSpeed , portMAX_DELAY );
		// Compare with the care speed
		if ( *Car_Speed < *ReceivedSpeed) {
			if (Car_Limit < *ReceivedSpeed) {
				// the car speed reaches its Limit.
				*Car_Speed = Car_Limit ;
				// send the new speed to the control task.
				xQueueSend(Uart_Transmit_Queue, Car_Speed,0);
			} else {
				// the car speed becomes the same front car speed.
				*Car_Speed = *ReceivedSpeed ;
				// send the new speed to the control task.
				xQueueSend(Uart_Transmit_Queue, Car_Speed,0);
			}
		} else if (*Car_Speed > *ReceivedSpeed) {
			// the car speed becomes the same front car speed.
			*Car_Speed = *ReceivedSpeed ;
			// send the new speed to the control task.
			xQueueSend(Uart_Transmit_Queue, Car_Speed,0);
		} else {
			// the car speed does not change.
			// send current speed to the control task.
			xQueueSend(Uart_Transmit_Queue, Car_Speed,0);
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the Task that Handle the Bump crossing Sitiuation : task 6 , it should take the highest periority when it starts.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vBumpHandlingTask(void* pvParameters)
{
	// the distance between the car and the bump.
	f32  	speed_difference		= 0	;
	f32		reduction_value			= 0 ;
	f32		new_speed				= 0 ;
	u8		distance_sections		= 0 ;
	u8		section_space			= 0	;
	f32		crossed_dist			= 0	;
	// local counter to detect the number of seconds.
	u16 	second_local_counter	= 0 ;
	// create the Timer
	Bump_Dist_Timer	 			= xTimerCreate("Bump Timer", _1S_, pdTRUE, NULL, &vDumpTimerCallBack );

	// at the beginning we suspend this task until we receive a notification of a bump.
	vTaskSuspend(tBumpHandlingTask);

		while(1)
		{
			if (second_local_counter == 0)
			{
				// calculate the differecnce between the current speed and the bump crossing speed.
				speed_difference = (*Car_Speed) - _BUMP_CROSS_SPEED_ ;

				/* if the division of the difference to ( 10 ) >= (_BUMP_CROSS_SPEED_ Km/H) ,
				 * then the speed should decreases by ( Car speed / 10 ) for each (_BUMP_DEFAULT_DIST_ / 10).
				 * But the reduction of the speed stop at (_BUMP_DEFAULT_DIST_ - 8*( _BUMP_DEFAULT_DIST_ / 10).
				 * if the division of the difference to ( 10 ) < (_BUMP_CROSS_SPEED_ Km/H) ,
				 * then the speed should decreases by ( Car speed / 6 ) for each (_BUMP_DEFAULT_DIST_ / 6).
				 * But the reduction of the speed stop at (_BUMP_DEFAULT_DIST_ - 4*( _BUMP_DEFAULT_DIST_ / 6).
				 */
				if (speed_difference >= _BUMP_CROSS_SPEED_) {
					distance_sections 	= 10 ;
					reduction_value   	= (*Car_Speed) / 10 ;
					section_space		=	_BUMP_DEFAULT_DIST_ / 10 ;
				}else {
					distance_sections 	=	 6 ;
					reduction_value   	=	(*Car_Speed) / 6 ;
					section_space		=	_BUMP_DEFAULT_DIST_ / 6 ;
				}

				//calculate the new speed
				new_speed =  (*Car_Speed) - (reduction_value);
				// decrease the distance sections by (1);
				distance_sections --;
				// increase the second_local_counter by (1)
				second_local_counter ++;

				// send the new speed
				xQueueSend(Uart_Transmit_Queue, &new_speed,0);

				// start the timer
				xTimerStart(Bump_Dist_Timer,_1S_);

			}
			else
			{
				// calculate the crossed distance = Car_speed in (KM/H) / time in (s).
				crossed_dist += (*Car_Speed)/(3600);
				if (crossed_dist >= section_space)
				{
					// reset the crossed_dist value.
					crossed_dist = 0;

					// decrease the distance sections by (1);
					distance_sections --;
					if (distance_sections > 2)
					{
						//calculate the new speed
						new_speed =  (*Car_Speed) - (reduction_value);

						// send the new speed
						xQueueSend(Uart_Transmit_Queue, &new_speed,0);
					}
					else
					{
						//the new speed will equal the "_BUMP_CROSS_SPEED_" , as it is not much higher.
						new_speed =  _BUMP_CROSS_SPEED_;

						// send the new speed
						xQueueSend(Uart_Transmit_Queue, &new_speed,0);
						// end the bump case.
						if (distance_sections == 0) {
							xTimerStop(Bump_Dist_Timer,0);
							second_local_counter = 0 ;
							crossed_dist = 0;
						}
					}
				}
				// increase the second_local_counter by (1)
				second_local_counter ++;
			}
			// suspend the task again.
			vTaskSuspend(tBumpHandlingTask);
		}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the Task that transmit the new speed though the Uart: task 7
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vTransmitToUartTask(void * pvParameters)
{
	f32 received_Speed = 0;
	f32 Old_Speed = *Car_Speed;
	while(1)
	{
		// receive the speed from the Queue.
		xQueueReceive(Uart_Transmit_Queue, &received_Speed , portMAX_DELAY);
		if (received_Speed != Old_Speed)
		{
			// store the new speed as the car speed.
			*Car_Speed = received_Speed;
			Old_Speed = *Car_Speed;
			// send the new speed.
			MCAL_UART_Transmit(&UART_2, (u8 *)Car_Speed, 1, 1000 , 255);
		}

	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*---------------------------------------------------------------------------------------------------------------------*/
